title: 触屏事件分发机制
date: 2015-12-13 11:11:37
tags: Android
---


``` java
public boolean dispatchTouchEvent(MotionEvent event) {
        // If the event should be handled by accessibility focus first.
	if (event.isTargetAccessibilityFocus()) {
            // We don't have focus or no virtual descendant has it, do not handle the event.
	if (!isAccessibilityFocusedViewOrHost()) {
		return false;
		}
            // We have focus and got the event, then use normal event dispatch.
            event.setTargetAccessibilityFocus(false);
        }

        boolean result = false;

        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(event, 0);
        }

        final int actionMasked = event.getActionMasked();
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Defensive cleanup for new gesture
            stopNestedScroll();
        }
        
        if (onFilterTouchEventForSecurity(event)) {
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null && li.mOnTouchListener != null
                    && (mViewFlags & ENABLED_MASK) == ENABLED
                    && li.mOnTouchListener.onTouch(this, event)) {
                result = true;
            }

            if (!result && onTouchEvent(event)) {
                result = true;
            }
        }

        if (!result && mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
        }

        // Clean up after nested scrolls if this is the end of a gesture;
        // also cancel it if we tried an ACTION_DOWN but we didn't want the rest
        // of the gesture.
        if (actionMasked == MotionEvent.ACTION_UP ||
                actionMasked == MotionEvent.ACTION_CANCEL ||
                (actionMasked == MotionEvent.ACTION_DOWN && !result)) {
            stopNestedScroll();
        }

        return result;
    }
    
    
```

 
> 分析源码：注意result这个boolean值。源码中li.mOnTouchLiistener != null，当通过setOnclickListener时，就不会为Null,紧接着会调用listener的onTouch(),如果onTouch()返回为true，则result为true，我们会看到如果result为true时，不会调用onTouchEvent(),result的结果就代表该事件是否消耗。

结论：

1. Android控件的Listener事件的触发顺序是：如果onTouch返回true 表示该listener消耗了事件，则该view的onTouchEvent不会被调用，在onTouchEvent()中，如果设置了clickListener，则会调用其onClick()方法。因此clickListener的优先级是最低的。
2. 如果onTouch返回true，则会阻止事件的传递，返回false事件会继续传递。
3. 如果控件不是enable的，就不会调用onTouchListener的onTouch()，会调用onTouchEvent




